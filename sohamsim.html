<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Water Treatment Control Panel</title>
    <!-- MQTT over WebSocket client -->
    <script src="https://unpkg.com/mqtt@5.3.5/dist/mqtt.min.js"></script>
    <style>
        :root {
            --color-primary: #2ea0cc;
            --color-success: #46b450;
            --color-warning: #ffb900;
            --color-danger: #dc3232;
            --color-bg: #f5f5f5;
            --color-card: #ffffff;
            --color-border: #ddd;
            --color-text: #1f1f1f;
            --color-text-secondary: #757575;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            padding: 20px;
            line-height: 1.6;
        }
        .header {
            background: linear-gradient(135deg, #2ea0cc 0%, #1e7ba8 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .header h1 { font-size: 28px; margin-bottom: 10px; }
        .connection-status { display: inline-flex; align-items: center; gap: 10px; background: rgba(255,255,255,0.15); padding: 8px 16px; border-radius: 20px; font-size: 14px; backdrop-filter: blur(10px); }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; animation: pulse 2s infinite; }
        .status-dot.connected { background: #46b450; }
        .status-dot.disconnected { background: #dc3232; animation: none; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .controls-section { background: var(--color-card); padding: 25px; border-radius: 12px; margin-bottom: 30px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .controls-section h2 { font-size: 20px; margin-bottom: 20px; color: var(--color-primary); display:flex; align-items:center; gap:10px; }
        .control-row { display:grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .control-group { display:flex; flex-direction:column; gap:8px; }
        .control-group label { font-weight:500; font-size:14px; color:var(--color-text); }

        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 30px; }
        .toggle-switch input { opacity:0; width:0; height:0; }
        .slider { position: absolute; cursor: pointer; top:0; left:0; right:0; bottom:0; background-color: #ccc; transition: .3s; border-radius: 30px; }
        .slider:before { position:absolute; content:""; height:22px; width:22px; left:4px; bottom:4px; background-color:white; transition:.3s; border-radius:50%; }
        input:checked + .slider { background-color: var(--color-success); }
        input:checked + .slider:before { transform: translateX(30px); }

        .btn { padding:12px 24px; border:none; border-radius:8px; font-size:14px; font-weight:600; cursor:pointer; transition: all 0.3s ease; display:inline-flex; align-items:center; gap:8px; text-transform:uppercase; letter-spacing:0.5px; }
        .btn-primary { background: var(--color-primary); color: white; }
        .btn-primary:hover { background: #1e7ba8; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(46,160,204,0.3); }
        .btn-success { background: var(--color-success); color: white; }
        .btn-success:hover { background: #3a9642; transform: translateY(-2px); }
        .btn-danger { background: var(--color-danger); color: white; }
        .btn-danger:hover { background: #b52828; transform: translateY(-2px); }

        input[type="number"], select { padding:10px; border:2px solid var(--color-border); border-radius:6px; font-size:14px; width:100%; transition:border-color 0.3s; }
        input[type="number"]:focus, select:focus { outline:none; border-color:var(--color-primary); }

        .stages-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap:20px; margin-top:20px; }
        .stage-card { background: var(--color-card); border-radius:12px; padding:20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-left: 5px solid var(--color-primary); }
        .stage-card.primary { border-left-color: #3498db; }
        .stage-card.secondary { border-left-color: #2ecc71; }
        .stage-card.tertiary { border-left-color: #9b59b6; }
        .stage-card.final { border-left-color: #f39c12; }
        .stage-card h3 { font-size:18px; margin-bottom:15px; display:flex; align-items:center; gap:10px; }
        .stage-icon { width:40px; height:40px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:20px; }

        .form-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap:12px; margin-bottom:15px; }
        .form-item { display:flex; flex-direction:column; gap:4px; }
        .form-item label { font-size:12px; color: var(--color-text-secondary); font-weight:500; }
        .form-item input { padding:8px; font-size:13px; }

        .stage-actions { display:flex; gap:10px; margin-top:15px; }
        .stage-actions button { flex:1; font-size:12px; padding:10px; }

        .log-section { background: var(--color-card); padding:20px; border-radius:12px; margin-top:30px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .log-section h2 { font-size:18px; margin-bottom:15px; color:var(--color-primary); }
        .log-container { background: #1e1e1e; color: #00ff00; padding:15px; border-radius:8px; font-family: 'Courier New', monospace; font-size:12px; max-height:400px; overflow-y:auto; }
        .log-entry { margin-bottom:8px; display:flex; gap:10px; }
        .log-time { color:#888; width:95px; flex-shrink:0; }
        .log-success { color:#46b450; }
        .log-error { color:#dc3232; }
        .log-info { color:#2ea0cc; }
        .log-in { color: #ffd966; } /* incoming messages */
        .log-out { color: #b3d9ff; } /* outgoing publishes */

        .stats-row { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px; margin-bottom:20px; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding:20px; border-radius:10px; text-align:center; }
        .stat-value { font-size:32px; font-weight:bold; margin-bottom:5px; }
        .stat-label { font-size:14px; opacity:0.9; }

        @media (max-width: 768px) {
            .stages-grid { grid-template-columns: 1fr; }
            .control-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üåä Water Treatment Digital Twin - Control Panel</h1>
        <div class="connection-status">
            <span class="status-dot disconnected" id="statusDot"></span>
            <span id="statusText">Simulation Mode Ready</span>
        </div>
    </div>

    <div class="controls-section">
        <h2>‚öôÔ∏è System Controls</h2>

        <div class="control-row">
            <div class="control-group">
                <label>Simulation Mode</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="simulationToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>

            <div class="control-group">
                <label>Update Interval (seconds)</label>
                <input type="number" id="updateInterval" value="5" min="1" max="60">
            </div>

            <div class="control-group">
                <label>Broadcast Mode</label>
                <select id="broadcastMode">
                    <option value="all">All Stages</option>
                    <option value="primary">Primary Only</option>
                    <option value="secondary">Secondary Only</option>
                    <option value="tertiary">Tertiary Only</option>
                    <option value="final">Final Only</option>
                </select>
            </div>
        </div>

        <div class="control-row">
            <button class="btn btn-success" onclick="startBroadcast()">‚ñ∂Ô∏è Start Simulation</button>
            <button class="btn btn-danger" onclick="stopBroadcast()">‚èπÔ∏è Stop Simulation</button>
            <button class="btn btn-primary" onclick="publishAllOnce()">üì§ Publish Once</button>
        </div>

        <div class="stats-row">
            <div class="stat-card">
                <div class="stat-value" id="publishCount">0</div>
                <div class="stat-label">Updates Published</div>
            </div>
            <div class="stat-card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                <div class="stat-value" id="errorCount">0</div>
                <div class="stat-label">Errors</div>
            </div>
            <div class="stat-card" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                <div class="stat-value" id="uptime">00:00</div>
                <div class="stat-label">Runtime</div>
            </div>
        </div>
    </div>

    <div class="stages-grid" id="stagesContainer"></div>

    <div class="log-section">
        <h2>üìä Activity Log</h2>
        <div class="log-container" id="logContainer">
            <div class="log-entry">
                <span class="log-time">[00:00:00]</span>
                <span class="log-info">Water Treatment Digital Twin initialized (2025-12-03 14:57 IST)</span>
            </div>
        </div>
    </div>

    <script>
        /***********************
         * Configuration
         ***********************/
        const MQTT_CONFIG = {
            // HiveMQ Cloud host you provided
            host: '9b39969bf84848cca34a2913622c0a2c.s1.eu.hivemq.cloud',
            // secure WebSocket port often 8884 for HiveMQ Cloud; change if needed
            port: 8884,
            // Use wss WebSocket path (many brokers use /mqtt for websockets)
            url: null, // we'll build below
            username: 'hydro',
            password: 'Hydroneil@123',
            topicPrefix: 'watertreatment'
        };

        // Build websocket URL (wss)
        MQTT_CONFIG.url = `wss://${MQTT_CONFIG.host}:${MQTT_CONFIG.port}/mqtt`;

        /***********************
         * Stage definitions
         ***********************/
        const STAGES = {
            primary: {
                name: 'Primary Stage', icon: 'üîµ', color: '#3498db', deviceId: 'ESP32_PRIMARY_001', tankLevel: 75,
                parameters: { ph:{min:6.5,max:7.5,unit:'pH',current:7.0}, turbidity_ntu:{min:100,max:300,unit:'NTU',current:220}, temperature_c:{min:18,max:30,unit:'¬∞C',current:25}, dissolved_oxygen_mg_l:{min:0.5,max:2.0,unit:'mg/L',current:1.2}, tds_mg_l:{min:400,max:800,unit:'mg/L',current:620}, conductivity_¬µs_cm:{min:500,max:900,unit:'¬µS/cm',current:720}, total_chlorine_mg_l:{min:0,max:0.5,unit:'mg/L',current:0.02}, hardness_mg_l:{min:100,max:250,unit:'mg/L',current:180}, alkalinity_mg_l:{min:100,max:200,unit:'mg/L',current:150}, flow_rate_m3_h:{min:300,max:450,unit:'m¬≥/h',current:380}, tank_level_percent:{min:0,max:100,unit:'%',current:75}, hour_of_day_hr:{min:0,max:23,unit:'hr',current:15}, water_source_id:{min:0,max:2,unit:'ID',current:0} }
            },
            secondary: {
                name: 'Secondary Stage', icon: 'üü¢', color: '#2ecc71', deviceId: 'ESP32_SECONDARY_002', tankLevel: 60,
                parameters: { ph:{min:6.8,max:7.8,unit:'pH',current:7.2}, turbidity_ntu:{min:10,max:40,unit:'NTU',current:25}, temperature_c:{min:20,max:28,unit:'¬∞C',current:25.5}, dissolved_oxygen_mg_l:{min:5.0,max:8.0,unit:'mg/L',current:6.8}, tds_mg_l:{min:400,max:800,unit:'mg/L',current:420}, conductivity_¬µs_cm:{min:500,max:900,unit:'¬µS/cm',current:680}, total_chlorine_mg_l:{min:0,max:0.5,unit:'mg/L',current:0.05}, hardness_mg_l:{min:100,max:250,unit:'mg/L',current:165}, alkalinity_mg_l:{min:100,max:200,unit:'mg/L',current:140}, flow_rate_m3_h:{min:300,max:450,unit:'m¬≥/h',current:375}, tank_level_percent:{min:0,max:100,unit:'%',current:60}, hour_of_day_hr:{min:0,max:23,unit:'hr',current:15}, water_source_id:{min:0,max:2,unit:'ID',current:0} }
            },
            tertiary: {
                name: 'Tertiary Stage', icon: 'üü£', color: '#9b59b6', deviceId: 'ESP32_TERTIARY_003', tankLevel: 80,
                parameters: { ph:{min:7.0,max:7.8,unit:'pH',current:7.4}, turbidity_ntu:{min:2,max:10,unit:'NTU',current:6}, temperature_c:{min:20,max:28,unit:'¬∞C',current:24.8}, dissolved_oxygen_mg_l:{min:6.0,max:9.0,unit:'mg/L',current:7.5}, tds_mg_l:{min:350,max:700,unit:'mg/L',current:380}, conductivity_¬µs_cm:{min:450,max:850,unit:'¬µS/cm',current:620}, total_chlorine_mg_l:{min:0.5,max:2.0,unit:'mg/L',current:1.2}, hardness_mg_l:{min:80,max:200,unit:'mg/L',current:145}, alkalinity_mg_l:{min:80,max:180,unit:'mg/L',current:125}, flow_rate_m3_h:{min:300,max:450,unit:'m¬≥/h',current:372}, tank_level_percent:{min:0,max:100,unit:'%',current:80}, hour_of_day_hr:{min:0,max:23,unit:'hr',current:15}, water_source_id:{min:0,max:2,unit:'ID',current:0} }
            },
            final: {
                name: 'Final Tank', icon: 'üü°', color: '#f39c12', deviceId: 'ESP32_FINAL_004', tankLevel: 70,
                parameters: { ph:{min:7.2,max:7.6,unit:'pH',current:7.4}, turbidity_ntu:{min:1,max:5,unit:'NTU',current:2.5}, temperature_c:{min:22,max:26,unit:'¬∞C',current:25}, dissolved_oxygen_mg_l:{min:7.0,max:9.0,unit:'mg/L',current:8.2}, tds_mg_l:{min:300,max:600,unit:'mg/L',current:320}, conductivity_¬µs_cm:{min:400,max:750,unit:'¬µS/cm',current:550}, total_chlorine_mg_l:{min:0.2,max:1.0,unit:'mg/L',current:0.6}, hardness_mg_l:{min:60,max:150,unit:'mg/L',current:110}, alkalinity_mg_l:{min:70,max:150,unit:'mg/L',current:105}, flow_rate_m3_h:{min:300,max:450,unit:'m¬≥/h',current:365}, tank_level_percent:{min:0,max:100,unit:'%',current:70}, hour_of_day_hr:{min:0,max:23,unit:'hr',current:15}, water_source_id:{min:0,max:2,unit:'ID',current:0} }
            }
        };

        /***********************
         * Global state
         ***********************/
        let broadcastInterval = null;
        let publishCount = 0;
        let errorCount = 0;
        let startTime = Date.now();
        let client = null; // mqtt client

        /***********************
         * Utility: logging / UI helpers
         ***********************/
        function addLog(message, type = 'info', prefixTime = true) {
            const container = document.getElementById('logContainer');
            const now = new Date();
            const time = now.toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const timeSpan = `<span class="log-time">[${time}]</span>`;
            const contentSpan = `<span class="log-${type}">${message}</span>`;
            entry.innerHTML = timeSpan + contentSpan;
            container.insertBefore(entry, container.firstChild);

            // keep last 200 entries (more generous)
            while (container.children.length > 200) container.removeChild(container.lastChild);
        }

        function updateCounts() {
            document.getElementById('publishCount').textContent = publishCount;
            document.getElementById('errorCount').textContent = errorCount;
        }

        function setConnectionStatus(connected, text) {
            const dot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            if (connected) {
                dot.classList.remove('disconnected');
                dot.classList.add('connected');
            } else {
                dot.classList.remove('connected');
                dot.classList.add('disconnected');
            }
            statusText.textContent = text;
        }

        /***********************
         * Generate & Manual data
         ***********************/
        function generateSensorData(stageKey) {
            const stageConfig = STAGES[stageKey];
            const sensors = {};
            for (const [param, config] of Object.entries(stageConfig.parameters)) {
                const current = config.current;
                const variance = (Math.random() - 0.5) * (config.max - config.min) * 0.05; // ¬±5% of range
                const value = Math.max(config.min, Math.min(config.max, current + variance));
                sensors[param] = { value: parseFloat(value.toFixed(2)), unit: config.unit, status: 'OK', critical: false };
            }
            return sensors;
        }

        function getManualData(stageKey) {
            const stageConfig = STAGES[stageKey];
            const sensors = {};
            for (const param of Object.keys(stageConfig.parameters)) {
                const input = document.getElementById(`${stageKey}_${param}`);
                if (!input) continue;
                const value = parseFloat(input.value);
                sensors[param] = { value: isNaN(value) ? stageConfig.parameters[param].current : parseFloat(value.toFixed(2)), unit: stageConfig.parameters[param].unit, status: 'OK', critical: false };
            }
            return sensors;
        }

        /***********************
         * MQTT: connect, subscribe, publish
         ***********************/
        function connectMQTT() {
            if (client && client.connected) {
                addLog('MQTT already connected', 'info');
                return;
            }

            addLog(`Connecting to MQTT broker ${MQTT_CONFIG.url} ...`, 'info');
            setConnectionStatus(false, 'Connecting to MQTT...');

            const clientId = `web-client-${Math.random().toString(16).slice(2, 10)}`;

            const options = {
                username: MQTT_CONFIG.username,
                password: MQTT_CONFIG.password,
                keepalive: 60,
                clean: true,
                reconnectPeriod: 4000,
                connectTimeout: 30 * 1000,
                clientId: clientId,
                protocolVersion: 5 // use MQTT v5 where possible
            };

            // connect using mqtt.js
            try {
                client = mqtt.connect(MQTT_CONFIG.url, options);
            } catch (err) {
                addLog(`MQTT connect error: ${err.message}`, 'error');
                setConnectionStatus(false, 'MQTT connection error');
                return;
            }

            client.on('connect', (connack) => {
                setConnectionStatus(true, 'üîó MQTT Connected successfully');
                addLog('üîó MQTT Connected successfully', 'success');
                // subscribe to topics we care about
                const topics = [
                    `${MQTT_CONFIG.topicPrefix}/primary/all`,
                    `${MQTT_CONFIG.topicPrefix}/secondary/all`,
                    `${MQTT_CONFIG.topicPrefix}/tertiary/all`,
                    `${MQTT_CONFIG.topicPrefix}/final/all`,
                    `${MQTT_CONFIG.topicPrefix}/machines/summary`
                ];
                topics.forEach(t => {
                    client.subscribe(t, { qos: 1 }, (err, granted) => {
                        if (err) {
                            addLog(`Subscribe ${t} failed: ${err.message}`, 'error');
                        } else {
                            addLog(`Subscribed to ${t} (qos ${granted && granted[0] ? granted[0].qos : '?'})`, 'info');
                        }
                    });
                });
            });

            client.on('reconnect', () => {
                setConnectionStatus(false, 'Reconnecting...');
                addLog('MQTT reconnecting...', 'info');
            });

            client.on('error', (err) => {
                errorCount++;
                updateCounts();
                addLog(`MQTT error: ${err.message}`, 'error');
                setConnectionStatus(false, 'MQTT Error');
            });

            client.on('close', () => {
                setConnectionStatus(false, 'Disconnected');
                addLog('MQTT connection closed', 'info');
            });

            client.on('offline', () => {
                setConnectionStatus(false, 'Offline');
                addLog('MQTT offline', 'info');
            });

            client.on('message', (topic, messageBuffer, packet) => {
                let message = messageBuffer.toString();
                try {
                    // try parse JSON for nicer log
                    const obj = JSON.parse(message);
                    message = JSON.stringify(obj, null, 0);
                } catch (e) { /* keep raw string */ }
                addLog(`IN ${topic} ‚Üí ${message}`, 'in');
                console.log('MQTT message', topic, message, packet);
            });
        }

        // safe publish with callback to know success/error
        function mqttPublish(topic, payloadObj, options = { qos: 1, retain: false }) {
            if (!client || !client.connected) {
                addLog(`Cannot publish, MQTT not connected ‚Üí ${topic}`, 'error');
                errorCount++;
                updateCounts();
                return;
            }

            const payload = (typeof payloadObj === 'string') ? payloadObj : JSON.stringify(payloadObj);

            client.publish(topic, payload, options, (err) => {
                if (err) {
                    errorCount++;
                    updateCounts();
                    addLog(`Publish ERROR ${topic}: ${err.message}`, 'error');
                    console.error('Publish error', err);
                } else {
                    publishCount++;
                    updateCounts();
                    addLog(`OUT ${topic} ‚Üí ${payload}`, 'out');
                    console.log('Published to', topic, payload);
                }
            });
        }

        /***********************
         * Publish helpers (stage + summary)
         ***********************/
        function publishStageData(stageKey, useSimulation = null) {
            const simulate = useSimulation !== null ? useSimulation : document.getElementById('simulationToggle').checked;
            const stageConfig = STAGES[stageKey];
            const sensors = simulate ? generateSensorData(stageKey) : getManualData(stageKey);

            const payload = {
                device: {
                    id: stageConfig.deviceId,
                    stage: stageKey,
                    location: stageConfig.name,
                    firmware: '2.1.0',
                    rssi: Math.floor(Math.random() * 30) - 75
                },
                timestamp: Date.now(),
                datetime: new Date().toISOString(),
                stage: stageKey,
                tankLevel: stageConfig.tankLevel,
                sensors: sensors
            };

            const topic = `${MQTT_CONFIG.topicPrefix}/${stageKey}/all`;
            // publish via mqtt
            mqttPublish(topic, payload);

            // Also update console log
            console.log(`üì§ ${stageKey.toUpperCase()} Stage Data:`, payload);
        }

        // Publish summary for machines (could be aggregated)
        function publishMachinesSummary() {
            // Build a short summary with tank levels & simple status
            const summary = {
                timestamp: Date.now(),
                datetime: new Date().toISOString(),
                machines: {}
            };
            for (const [key, stage] of Object.entries(STAGES)) {
                summary.machines[key] = {
                    deviceId: stage.deviceId,
                    tankLevel: stage.tankLevel,
                    lastUpdateDelayMs: Math.floor(Math.random() * 1000) // demo field
                };
            }
            const topic = `${MQTT_CONFIG.topicPrefix}/machines/summary`;
            mqttPublish(topic, summary);
        }

        function publishAllStages() {
            const mode = document.getElementById('broadcastMode').value;
            if (mode === 'all') {
                for (const stage of Object.keys(STAGES)) {
                    publishStageData(stage);
                }
            } else {
                publishStageData(mode);
            }
            // publish a summary occasionally or on demand
            publishMachinesSummary();
        }

        /***********************
         * Broadcast control
         ***********************/
        function startBroadcast() {
            if (broadcastInterval) {
                addLog('Simulation already running', 'info');
                return;
            }
            // ensure MQTT is connected (connect automatically if not)
            connectMQTT();

            const intervalSec = parseInt(document.getElementById('updateInterval').value) || 5;
            const intervalMs = Math.max(1000, intervalSec * 1000);

            broadcastInterval = setInterval(() => {
                publishAllStages();
            }, intervalMs);

            // publish immediately once
            publishAllStages();
            addLog(`Simulation started (interval: ${intervalSec}s)`, 'success');
        }

        function stopBroadcast() {
            if (broadcastInterval) {
                clearInterval(broadcastInterval);
                broadcastInterval = null;
                addLog('Simulation stopped', 'info');
            } else {
                addLog('No simulation running', 'info');
            }
        }

        function publishAllOnce() {
            // connect if not already
            connectMQTT();
            publishAllStages();
        }

        /***********************
         * UI: create stage forms
         ***********************/
        function createStageForm(stageKey) {
            const stage = STAGES[stageKey];
            const card = document.createElement('div');
            card.className = `stage-card ${stageKey}`;

            let formHTML = `
                <h3>
                    <span class="stage-icon" style="background: ${stage.color}20; color: ${stage.color};">
                        ${stage.icon}
                    </span>
                    ${stage.name} (Tank: ${stage.tankLevel}%)
                </h3>
                <div class="form-grid">
            `;

            for (const [param, config] of Object.entries(stage.parameters)) {
                const defaultValue = config.current;
                // beautify label
                const label = param.replace(/_/g, ' ').replace(/mg l|cfu 100ml|ntu|ml l|m3 h|c/g, '').trim();
                const step = (config.max - config.min) > 100 ? '1' : '0.01';
                formHTML += `
                    <div class="form-item">
                        <label>${label} (${config.unit})</label>
                        <input type="number"
                               id="${stageKey}_${param}"
                               value="${defaultValue}"
                               min="${config.min}"
                               max="${config.max}"
                               step="${step}">
                    </div>
                `;
            }

            formHTML += `
                </div>
                <div class="stage-actions">
                    <button class="btn btn-primary" onclick="publishStageData('${stageKey}', false)">üì§ Manual</button>
                    <button class="btn btn-success" onclick="publishStageData('${stageKey}', true)">üé≤ Simulate</button>
                </div>
            `;
            card.innerHTML = formHTML;
            return card;
        }

        function initUI() {
            const container = document.getElementById('stagesContainer');
            for (const stageKey of Object.keys(STAGES)) {
                container.appendChild(createStageForm(stageKey));
            }
        }

        /***********************
         * Uptime counter
         ***********************/
        function updateUptime() {
            setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('uptime').textContent = `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
            }, 1000);
        }

        /***********************
         * Init on load
         ***********************/
        window.addEventListener('DOMContentLoaded', () => {
            initUI();
            updateUptime();
            addLog('Control panel ready - 2025-12-03 15:02 IST', 'success');
            addLog('4 stages configured: Primary, Secondary, Tertiary, Final', 'info');
            addLog('All parameters initialized with realistic values', 'info');

            // Optionally auto-connect to MQTT on load:
            // If you prefer to connect only when user starts simulation, comment the next line.
            connectMQTT();
        });

        // cleanup
        window.addEventListener('beforeunload', () => {
            if (broadcastInterval) clearInterval(broadcastInterval);
            if (client && client.connected) client.end(true);
        });
    </script>
</body>
</html>
