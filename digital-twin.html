<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HydroNail Digital Twin - Smart India Hackathon 2025</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: #fff;
            overflow: hidden;
        }

        #container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            grid-template-rows: 60px 1fr 200px;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }

        /* Header */
        #header {
            grid-column: 1 / 4;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        #header h1 {
            font-size: 24px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #00ff88;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Left Sidebar - Machine List */
        #machines-panel {
            grid-row: 2 / 4;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .machine-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #00d4ff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .machine-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .machine-card.running {
            border-left-color: #00ff88;
        }

        .machine-card.stopped {
            border-left-color: #ff4444;
        }

        .machine-card.maintenance {
            border-left-color: #ffaa00;
        }

        .machine-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .machine-stats {
            font-size: 11px;
            opacity: 0.8;
        }

        /* Center - 3D Viewport */
        #viewport {
            grid-row: 2 / 3;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .viewport-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00d4ff;
            color: #00d4ff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: #00d4ff;
            color: #000;
        }

        /* Right Sidebar - Control Panel */
        #control-panel {
            grid-row: 2 / 4;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .control-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .control-section h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-label {
            font-size: 13px;
            opacity: 0.8;
        }

        .metric-value {
            font-weight: bold;
            color: #00ff88;
        }

        .command-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .cmd-btn {
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid #00d4ff;
            color: #00d4ff;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .cmd-btn:hover {
            background: #00d4ff;
            color: #000;
        }

        .cmd-btn.danger {
            border-color: #ff4444;
            color: #ff4444;
        }

        .cmd-btn.danger:hover {
            background: #ff4444;
            color: #fff;
        }

        /* Bottom Panel - Metrics */
        #metrics-panel {
            grid-column: 2 / 3;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .metric-card h4 {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 10px;
        }

        .metric-card .value {
            font-size: 28px;
            font-weight: bold;
            color: #00ff88;
        }

        .metric-card .unit {
            font-size: 12px;
            opacity: 0.6;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        /* Loading indicator */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00d4ff;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Header -->
        <div id="header">
            <h1>üåä HydroNail Digital Twin</h1>
            <div class="connection-status">
                <span>API Status:</span>
                <div class="status-indicator" id="api-status"></div>
                <span id="api-status-text">Connecting...</span>
            </div>
        </div>

        <!-- Left Panel - Machines -->
        <div id="machines-panel">
            <h2 style="color: #00d4ff; margin-bottom: 15px;">Machines</h2>
            <div id="machines-list"></div>
        </div>

        <!-- Center - 3D Viewport -->
        <div id="viewport">
            <div class="viewport-controls">
                <button class="control-btn" onclick="resetCamera()">Reset View</button>
                <button class="control-btn" onclick="toggleAnimation()">Toggle Flow</button>
            </div>
            <div id="canvas-container"></div>
        </div>

        <!-- Right Panel - Control -->
        <div id="control-panel">
            <h2 style="color: #00d4ff; margin-bottom: 15px;">Control Panel</h2>
            <div id="selected-machine-info">
                <p style="opacity: 0.6;">Select a machine to view details</p>
            </div>
        </div>

        <!-- Bottom Panel - Metrics -->
        <div id="metrics-panel">
            <div class="metric-card">
                <h4>Total Power</h4>
                <div class="value" id="total-power">0</div>
                <div class="unit">kW</div>
            </div>
            <div class="metric-card">
                <h4>Running Machines</h4>
                <div class="value" id="running-machines">0</div>
                <div class="unit">/ 16</div>
            </div>
            <div class="metric-card">
                <h4>Efficiency</h4>
                <div class="value" id="avg-efficiency">0</div>
                <div class="unit">%</div>
            </div>
            <div class="metric-card">
                <h4>Water Quality</h4>
                <div class="value" id="quality-score">0</div>
                <div class="unit">/100</div>
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Main Application Script -->
    <script>
        // ============================================================
// HYDRONAIL DIGITAL TWIN - 3D VISUALIZATION
// Smart India Hackathon 2025 | Team Nova_Minds
// ============================================================

// API Configuration
const API_BASE_URL = 'http://localhost:5000/api';
let API_CONNECTED = false;

// Three.js Scene Setup
let scene, camera, renderer, controls;
let machineObjects = {};
let waterParticles = [];
let animationPaused = false;

// Data Storage
let machinesData = {};
let selectedMachineId = null;

// Machine positions in 3D space (arranged in treatment flow)
const MACHINE_POSITIONS = {
    // Screening Stage
    'BAR_SCREEN_01': { x: -30, y: 0, z: 10, color: 0x00ff88, stage: 'screening' },
    
    // Grit Removal (Primary)
    'GRIT_PUMP_01': { x: -20, y: 0, z: 10, color: 0x00d4ff, stage: 'primary' },
    'GRIT_AERATOR_01': { x: -20, y: 0, z: -10, color: 0x00d4ff, stage: 'primary' },
    
    // Aeration (Secondary)
    'AERATION_BLOWER_01': { x: -5, y: 5, z: 15, color: 0x4488ff, stage: 'secondary' },
    'AERATION_BLOWER_02': { x: -5, y: 5, z: 0, color: 0x4488ff, stage: 'secondary' },
    'RAS_PUMP_01': { x: -5, y: 0, z: -15, color: 0x4488ff, stage: 'secondary' },
    
    // Filtration (Tertiary)
    'PSF_PUMP_01': { x: 10, y: 0, z: 15, color: 0xff8800, stage: 'tertiary' },
    'ACF_PUMP_01': { x: 10, y: 0, z: 5, color: 0xff8800, stage: 'tertiary' },
    'UF_PUMP_01': { x: 10, y: 0, z: -5, color: 0xff8800, stage: 'tertiary' },
    'RO_HP_PUMP_01': { x: 10, y: 0, z: -15, color: 0xff8800, stage: 'tertiary' },
    
    // Disinfection (Final)
    'UV_SYSTEM_01': { x: 25, y: 0, z: 5, color: 0xff00ff, stage: 'final' },
    'OZONE_GEN_01': { x: 25, y: 0, z: -5, color: 0xff00ff, stage: 'final' },
    
    // Sludge Treatment
    'SLUDGE_PUMP_01': { x: 0, y: -5, z: 20, color: 0x888888, stage: 'sludge' },
    'THICKENER_RAKE_01': { x: 0, y: -5, z: 25, color: 0x888888, stage: 'sludge' },
    
    // Dewatering
    'SCREW_PRESS_01': { x: 15, y: -5, z: 25, color: 0xaaaaaa, stage: 'dewatering' },
    'BELT_PRESS_01': { x: 15, y: -5, z: 30, color: 0xaaaaaa, stage: 'dewatering' }
};

// ============================================================
// INITIALIZATION
// ============================================================

function init() {
    console.log('üöÄ Initializing HydroNail Digital Twin...');
    
    // Setup Three.js scene
    setupScene();
    
    // Create 3D plant
    createPlant();
    
    // Start animation loop
    animate();
    
    // Connect to API
    connectToAPI();
    
    // Start data polling
    setInterval(updateData, 3000); // Update every 3 seconds
}

// ============================================================
// THREE.JS SCENE SETUP
// ============================================================

function setupScene() {
    const container = document.getElementById('canvas-container');
    
    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1929);
    scene.fog = new THREE.Fog(0x0a1929, 50, 200);
    
    // Camera
    camera = new THREE.PerspectiveCamera(
        60,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
    );
    camera.position.set(0, 30, 60);
    camera.lookAt(0, 0, 0);
    
    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);
    
    // Controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2;
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(50, 50, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    const pointLight = new THREE.PointLight(0x00d4ff, 0.5, 100);
    pointLight.position.set(0, 20, 0);
    scene.add(pointLight);
    
    // Grid
    const gridHelper = new THREE.GridHelper(100, 20, 0x00d4ff, 0x1a3a4a);
    scene.add(gridHelper);
    
    // Handle window resize
    window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
    const container = document.getElementById('canvas-container');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

// ============================================================
// 3D PLANT CREATION
// ============================================================

function createPlant() {
    // Create machines
    Object.entries(MACHINE_POSITIONS).forEach(([machineId, config]) => {
        createMachine(machineId, config);
    });
    
    // Create pipelines
    createPipelines();
    
    // Create tanks
    createTanks();
    
    // Create water flow particles
    createWaterFlowParticles();
}

function createMachine(machineId, config) {
    const group = new THREE.Group();
    
    // Machine body (cylinder for pumps/blowers, box for others)
    const isRotary = machineId.includes('PUMP') || machineId.includes('BLOWER');
    
    let geometry, material;
    
    if (isRotary) {
        // Cylinder for rotating machines
        geometry = new THREE.CylinderGeometry(1.5, 1.5, 3, 16);
        material = new THREE.MeshPhongMaterial({
            color: config.color,
            emissive: config.color,
            emissiveIntensity: 0.2,
            shininess: 100
        });
    } else {
        // Box for other equipment
        geometry = new THREE.BoxGeometry(2, 3, 2);
        material = new THREE.MeshPhongMaterial({
            color: config.color,
            emissive: config.color,
            emissiveIntensity: 0.2
        });
    }
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.userData = { machineId: machineId, isRotary: isRotary };
    group.add(mesh);
    
    // Status indicator (glowing sphere on top)
    const indicatorGeometry = new THREE.SphereGeometry(0.4, 16, 16);
    const indicatorMaterial = new THREE.MeshBasicMaterial({
        color: 0xff4444,
        emissive: 0xff4444,
        emissiveIntensity: 1
    });
    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
    indicator.position.y = 2;
    indicator.userData = { isIndicator: true };
    group.add(indicator);
    
    // Label
    createLabel(group, machineId.replace(/_/g, ' '), 3);
    
    // Position
    group.position.set(config.x, config.y, config.z);
    
    // Store reference
    machineObjects[machineId] = group;
    
    // Add click handler
    mesh.callback = () => selectMachine(machineId);
    
    scene.add(group);
}

function createLabel(parent, text, yOffset) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;
    
    context.fillStyle = 'rgba(0, 0, 0, 0.7)';
    context.fillRect(0, 0, 256, 64);
    
    context.font = 'bold 20px Arial';
    context.fillStyle = '#00d4ff';
    context.textAlign = 'center';
    context.fillText(text, 128, 40);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(4, 1, 1);
    sprite.position.y = yOffset;
    
    parent.add(sprite);
}

function createPipelines() {
    const pipelinePaths = [
        // Screening to Primary
        [[-30, 0, 10], [-25, 0, 10], [-20, 0, 10]],
        // Primary to Secondary
        [[-20, 0, 10], [-15, 0, 10], [-10, 0, 10], [-5, 0, 15]],
        // Secondary to Tertiary
        [[-5, 0, -15], [0, 0, -15], [5, 0, -15], [10, 0, -15]],
        // Tertiary to Final
        [[10, 0, 15], [15, 0, 15], [20, 0, 15], [25, 0, 5]]
    ];
    
    pipelinePaths.forEach(path => {
        const curve = new THREE.CatmullRomCurve3(
            path.map(p => new THREE.Vector3(...p))
        );
        
        const geometry = new THREE.TubeGeometry(curve, 20, 0.3, 8, false);
        const material = new THREE.MeshPhongMaterial({
            color: 0x2266aa,
            transparent: true,
            opacity: 0.7,
            emissive: 0x0044aa,
            emissiveIntensity: 0.3
        });
        
        const pipe = new THREE.Mesh(geometry, material);
        pipe.castShadow = true;
        scene.add(pipe);
    });
}

function createTanks() {
    const tanks = [
        { x: -25, z: 0, label: 'Primary Tank' },
        { x: 0, z: 0, label: 'Secondary Tank' },
        { x: 20, z: 0, label: 'Tertiary Tank' }
    ];
    
    tanks.forEach(tank => {
        const geometry = new THREE.CylinderGeometry(5, 5, 8, 32);
        const material = new THREE.MeshPhongMaterial({
            color: 0x1144aa,
            transparent: true,
            opacity: 0.3,
            emissive: 0x0033aa,
            emissiveIntensity: 0.2
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(tank.x, 0, tank.z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
        
        createLabel(mesh, tank.label, 5);
    });
}

function createWaterFlowParticles() {
    const particleCount = 200;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 60;
        positions[i * 3 + 1] = Math.random() * 5;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: 0x00aaff,
        size: 0.3,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(geometry, material);
    waterParticles.push(particles);
    scene.add(particles);
}

// ============================================================
// ANIMATION LOOP
// ============================================================

function animate() {
    requestAnimationFrame(animate);
    
    controls.update();
    
    if (!animationPaused) {
        // Rotate running machines
        Object.entries(machineObjects).forEach(([machineId, group]) => {
            const machineData = machinesData[machineId];
            if (machineData && machineData.status === 'running') {
                const speed = (machineData.speed_percent || 50) / 100;
                group.children[0].rotation.y += 0.02 * speed;
            }
        });
        
        // Animate water particles
        waterParticles.forEach(particles => {
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += 0.05; // Flow in X direction
                if (positions[i] > 30) positions[i] = -30;
            }
            particles.geometry.attributes.position.needsUpdate = true;
        });
    }
    
    renderer.render(scene, camera);
}

// ============================================================
// API CONNECTION
// ============================================================

async function connectToAPI() {
    try {
        const response = await fetch(`${API_BASE_URL}/status`);
        if (response.ok) {
            API_CONNECTED = true;
            updateConnectionStatus(true);
            console.log('‚úÖ Connected to API');
        }
    } catch (error) {
        API_CONNECTED = false;
        updateConnectionStatus(false);
        console.log('‚ö†Ô∏è API not available, retrying...');
        setTimeout(connectToAPI, 5000);
    }
}

function updateConnectionStatus(connected) {
    const indicator = document.getElementById('api-status');
    const text = document.getElementById('api-status-text');
    
    if (connected) {
        indicator.classList.add('connected');
        text.textContent = 'Connected';
    } else {
        indicator.classList.remove('connected');
        text.textContent = 'Disconnected';
    }
}

// ============================================================
// DATA FETCHING & UPDATE
// ============================================================

async function updateData() {
    if (!API_CONNECTED) return;
    
    try {
        // Fetch all machines data
        const response = await fetch(`${API_BASE_URL}/machines`);
        const data = await response.json();
        
        if (data.status === 'success') {
            machinesData = data.machines;
            updateMachinesUI();
            updateMachinesVisuals();
            updateMetrics(data.summary);
        }
    } catch (error) {
        console.error('Error fetching data:', error);
    }
}

function updateMachinesUI() {
    const machinesList = document.getElementById('machines-list');
    machinesList.innerHTML = '';
    
    Object.entries(machinesData).forEach(([machineId, data]) => {
        const card = document.createElement('div');
        card.className = `machine-card ${data.status || 'stopped'}`;
        card.onclick = () => selectMachine(machineId);
        
        card.innerHTML = `
            <div class="machine-name">${data.name || machineId}</div>
            <div class="machine-stats">
                Status: ${(data.status || 'unknown').toUpperCase()}<br>
                Power: ${(data.power_kw || 0).toFixed(1)} kW<br>
                Speed: ${(data.speed_percent || 0).toFixed(0)}%
            </div>
        `;
        
        machinesList.appendChild(card);
    });
}

function updateMachinesVisuals() {
    Object.entries(machinesData).forEach(([machineId, data]) => {
        const machineGroup = machineObjects[machineId];
        if (!machineGroup) return;
        
        // Update status indicator color
        const indicator = machineGroup.children.find(child => child.userData.isIndicator);
        if (indicator) {
            const color = data.status === 'running' ? 0x00ff88 :
                         data.status === 'maintenance' ? 0xffaa00 : 0xff4444;
            indicator.material.color.setHex(color);
            indicator.material.emissive.setHex(color);
        }
        
        // Update machine color intensity based on power
        const mesh = machineGroup.children[0];
        const intensity = (data.power_kw || 0) / (data.rated_power_kw || 100);
        mesh.material.emissiveIntensity = 0.2 + (intensity * 0.5);
    });
}

function updateMetrics(summary) {
    if (!summary) return;
    
    document.getElementById('total-power').textContent = 
        (summary.total_power_kw || 0).toFixed(1);
    document.getElementById('running-machines').textContent = 
        summary.running || 0;
    document.getElementById('avg-efficiency').textContent = 
        (summary.average_efficiency || 0).toFixed(1);
    
    // Quality score from water quality prediction
    fetchWaterQuality();
}

async function fetchWaterQuality() {
    try {
        const response = await fetch(`${API_BASE_URL}/water-quality/final`);
        const data = await response.json();
        
        if (data.output && data.output.quality_score) {
            document.getElementById('quality-score').textContent = 
                data.output.quality_score.toFixed(1);
        }
    } catch (error) {
        console.error('Error fetching water quality:', error);
    }
}

// ============================================================
// MACHINE SELECTION & CONTROL
// ============================================================

function selectMachine(machineId) {
    selectedMachineId = machineId;
    const data = machinesData[machineId];
    
    if (!data) return;
    
    const panel = document.getElementById('selected-machine-info');
    panel.innerHTML = `
        <div class="control-section">
            <h3>${data.name || machineId}</h3>
            <div class="metric">
                <span class="metric-label">Status</span>
                <span class="metric-value">${(data.status || 'unknown').toUpperCase()}</span>
            </div>
            <div class="metric">
                <span class="metric-label">Power</span>
                <span class="metric-value">${(data.power_kw || 0).toFixed(2)} kW</span>
            </div>
            <div class="metric">
                <span class="metric-label">Speed</span>
                <span class="metric-value">${(data.speed_percent || 0).toFixed(1)}%</span>
            </div>
            <div class="metric">
                <span class="metric-label">Temperature</span>
                <span class="metric-value">${(data.temperature_c || 0).toFixed(1)}¬∞C</span>
            </div>
            <div class="metric">
                <span class="metric-label">Efficiency</span>
                <span class="metric-value">${(data.efficiency_percent || 0).toFixed(1)}%</span>
            </div>
            <div class="metric">
                <span class="metric-label">Health Score</span>
                <span class="metric-value">${(data.health_score || 0).toFixed(1)}</span>
            </div>
            <div class="metric">
                <span class="metric-label">Runtime</span>
                <span class="metric-value">${(data.runtime_hours || 0).toFixed(0)} hrs</span>
            </div>
            
            <div class="command-buttons">
                <button class="cmd-btn" onclick="sendCommand('${machineId}', 'start')">
                    ‚ñ∂ START
                </button>
                <button class="cmd-btn danger" onclick="sendCommand('${machineId}', 'stop')">
                    ‚èπ STOP
                </button>
                <button class="cmd-btn" onclick="sendCommand('${machineId}', 'auto')">
                    ü§ñ AUTO MODE
                </button>
                <button class="cmd-btn" onclick="sendCommand('${machineId}', 'manual')">
                    ‚úã MANUAL MODE
                </button>
            </div>
            
            <div style="margin-top: 15px;">
                <label style="font-size: 12px; opacity: 0.8;">Set Speed (%)</label>
                <input type="range" min="0" max="100" value="${data.speed_percent || 50}" 
                       style="width: 100%;" 
                       oninput="updateSpeedDisplay('${machineId}', this.value)"
                       onchange="sendSpeedCommand('${machineId}', this.value)">
                <div style="text-align: center; color: #00d4ff; font-weight: bold;" 
                     id="speed-display-${machineId}">${data.speed_percent || 50}%</div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Failure Prediction</h3>
            <div class="metric">
                <span class="metric-label">Risk Level</span>
                <span class="metric-value" style="color: ${
                    (data.failure_risk_percent || 0) > 70 ? '#ff4444' :
                    (data.failure_risk_percent || 0) > 40 ? '#ffaa00' : '#00ff88'
                }">${data.failure_risk_percent || 0}%</span>
            </div>
            <button class="cmd-btn" onclick="predictFailure('${machineId}')">
                üîç Check Equipment Health
            </button>
        </div>
    `;
}

async function sendCommand(machineId, action) {
    if (!API_CONNECTED) {
        alert('Not connected to API');
        return;
    }
    
    try {
        let endpoint;
        let body = {};
        
        if (action === 'start') {
            endpoint = `${API_BASE_URL}/control/${machineId}/start`;
        } else if (action === 'stop') {
            endpoint = `${API_BASE_URL}/control/${machineId}/stop`;
        } else if (action === 'auto' || action === 'manual') {
            endpoint = `${API_BASE_URL}/control/${machineId}/mode`;
            body = { mode: action };
        }
        
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        
        const result = await response.json();
        console.log('Command result:', result);
        
        // Refresh data immediately
        setTimeout(updateData, 500);
        
    } catch (error) {
        console.error('Error sending command:', error);
        alert('Failed to send command');
    }
}

async function sendSpeedCommand(machineId, speed) {
    if (!API_CONNECTED) return;
    
    try {
        const response = await fetch(`${API_BASE_URL}/control/${machineId}/speed`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ speed: parseFloat(speed) })
        });
        
        const result = await response.json();
        console.log('Speed command result:', result);
        
        setTimeout(updateData, 500);
        
    } catch (error) {
        console.error('Error setting speed:', error);
    }
}

function updateSpeedDisplay(machineId, speed) {
    document.getElementById(`speed-display-${machineId}`).textContent = `${speed}%`;
}

async function predictFailure(machineId) {
    try {
        const response = await fetch(`${API_BASE_URL}/equipment-failure/${machineId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        
        const result = await response.json();
        
        alert(`Equipment Health Analysis:\n\n` +
              `Risk Level: ${result.failure_prediction?.risk_level}\n` +
              `Failure Probability: ${result.failure_prediction?.failure_probability_percent}%\n` +
              `Recommended Action: ${result.failure_prediction?.recommended_action}`);
        
    } catch (error) {
        console.error('Error predicting failure:', error);
    }
}

// ============================================================
// CAMERA & ANIMATION CONTROLS
// ============================================================

function resetCamera() {
    camera.position.set(0, 30, 60);
    controls.target.set(0, 0, 0);
    controls.update();
}

function toggleAnimation() {
    animationPaused = !animationPaused;
}

// ============================================================
// START APPLICATION
// ============================================================

window.addEventListener('load', init);

    </script>
</body>
</html>
